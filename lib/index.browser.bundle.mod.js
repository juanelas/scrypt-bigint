const e={"SHA-1":{outputLength:20,blockSize:64},"SHA-256":{outputLength:32,blockSize:64},"SHA-384":{outputLength:48,blockSize:128},"SHA-512":{outputLength:64,blockSize:128}};function r(r,i,o,a,s="SHA-256"){return new Promise((f,u)=>{s in e||u(new RangeError("Valid hash algorithm values are any of "+Object.keys(e))),"string"==typeof r?r=(new TextEncoder).encode(r):r instanceof ArrayBuffer?r=new Uint8Array(r):ArrayBuffer.isView(r)||u(RangeError("P should be string, ArrayBuffer, TypedArray, DataView")),"string"==typeof i?i=(new TextEncoder).encode(i):i instanceof ArrayBuffer?i=new Uint8Array(i):ArrayBuffer.isView(i)||u(RangeError("S should be string, ArrayBuffer, TypedArray, DataView")),crypto.subtle.importKey("raw",r,"PBKDF2",!1,["deriveBits"]).then(c=>{const l={name:"PBKDF2",hash:s,salt:i,iterations:o};crypto.subtle.deriveBits(l,c,8*a).then(e=>f(e),c=>{(async function(r,i,o,a,s){if(!(s in e))throw new RangeError("Valid hash algorithm values are any of "+Object.keys(e));if(!Number.isInteger(o)||o<=0)throw new RangeError("c must be a positive integer");const f=e[s].outputLength;if(!Number.isInteger(a)||a<=0||a>=(2**32-1)*f)throw new RangeError("dkLen must be a positive integer < (2 ** 32 - 1) * hLen");const u=Math.ceil(a/f),c=a-(u-1)*f,l=new Array(u);0===r.length&&(r=new Uint8Array(e[s].blockSize));r=await crypto.subtle.importKey("raw",r,{name:"HMAC",hash:{name:s}},!0,["sign"]);const w=async function(e,r){const t=await crypto.subtle.sign("HMAC",e,r);return new Uint8Array(t)};for(let e=0;e<u;e++)l[e]=await y(r,i,o,e+1);async function y(e,r,i,o){const a=await w(e,t(r,function(e){const r=new ArrayBuffer(4);return new DataView(r).setUint32(0,e,!1),new Uint8Array(r)}(o)));let s=a;for(let r=1;r<i;r++)s=await w(e,s),n(a,s);return a}return l[u-1]=l[u-1].slice(0,c),t(...l).buffer})(r,i,o,a,s).then(e=>f(e),e=>u(e))})},e=>u(e))})}function t(...e){const r=e.reduce((e,r)=>e+r.length,0);if(!e.length)throw new RangeError("Cannot concat no arrays");const t=new Uint8Array(r);let n=0;for(const r of e)t.set(r,n),n+=r.length;return t}function n(e,r){for(let t=0;t<e.length;t++)e[t]^=r[t]}function i(e){function r(e,r){return e<<r|e>>>32-r}const t=e.slice(0);for(let e=8;e>0;e-=2)t[4]^=r(t[0]+t[12],7),t[8]^=r(t[4]+t[0],9),t[12]^=r(t[8]+t[4],13),t[0]^=r(t[12]+t[8],18),t[9]^=r(t[5]+t[1],7),t[13]^=r(t[9]+t[5],9),t[1]^=r(t[13]+t[9],13),t[5]^=r(t[1]+t[13],18),t[14]^=r(t[10]+t[6],7),t[2]^=r(t[14]+t[10],9),t[6]^=r(t[2]+t[14],13),t[10]^=r(t[6]+t[2],18),t[3]^=r(t[15]+t[11],7),t[7]^=r(t[3]+t[15],9),t[11]^=r(t[7]+t[3],13),t[15]^=r(t[11]+t[7],18),t[1]^=r(t[0]+t[3],7),t[2]^=r(t[1]+t[0],9),t[3]^=r(t[2]+t[1],13),t[0]^=r(t[3]+t[2],18),t[6]^=r(t[5]+t[4],7),t[7]^=r(t[6]+t[5],9),t[4]^=r(t[7]+t[6],13),t[5]^=r(t[4]+t[7],18),t[11]^=r(t[10]+t[9],7),t[8]^=r(t[11]+t[10],9),t[9]^=r(t[8]+t[11],13),t[10]^=r(t[9]+t[8],18),t[12]^=r(t[15]+t[14],7),t[13]^=r(t[12]+t[15],9),t[14]^=r(t[13]+t[12],13),t[15]^=r(t[14]+t[13],18);for(let r=0;r<16;r++)e[r]=t[r]+e[r]}function o(e){const r=e.byteLength/128,t=16*(2*r-1),n=e.slice(t,t+16),o=new Uint32Array(e.length/2);let a=!0;for(let t=0;t<2*r;t++){const r=16*t;u(n,e.subarray(r,r+16)),i(n);const s=16*(t>>1);if(a)for(let r=0;r<16;r++)e[s+r]=n[r];else for(let e=0;e<16;e++)o[s+e]=n[e];a=!a}const s=16*r;for(let r=0;r<s;r++)e[s+r]=o[r]}function a(e,r){const t=e.byteLength/128,n=new Array(r);for(let t=0;t<r;t++)n[t]=e.slice(0),o(e);function i(e){const n=64*(2*t-1);return new DataView(e.buffer,n,64).getUint32(0,!0)%r}for(let t=0;t<r;t++){u(e,n[i(e)]),o(e)}}async function s(e,t,n,i={}){if("string"==typeof e)e=(new TextEncoder).encode(e);else if(e instanceof ArrayBuffer)e=new Uint8Array(e);else if(!ArrayBuffer.isView(e))throw RangeError("P should be string, ArrayBuffer, TypedArray, DataView");if("string"==typeof t)t=(new TextEncoder).encode(t);else if(t instanceof ArrayBuffer)t=new Uint8Array(t);else if(!ArrayBuffer.isView(t))throw RangeError("S should be string, ArrayBuffer, TypedArray, DataView");if(!Number.isInteger(n)||n<=0||n>137438953440)throw RangeError("dkLen is the intended output length in octets of the derived key; a positive integer less than or equal to (2^32 - 1) * hLen where hLen is 32");let{N:o,r:s,p:f}=i;if(o=void 0===o?131072:o,s=void 0===s?8:s,f=void 0===f?1:f,!Number.isInteger(o)||o<=0||0!=(o&o-1))throw RangeError("N must be a power of 2");if(!Number.isInteger(s)||s<=0||!Number.isInteger(f)||f<=0||f*s>1073741823.75)throw RangeError("Parallelization parameter p and blocksize parameter r must be positive integers satisfying p ≤ (2^32− 1) * hLen / MFLen where hLen is 32 and MFlen is 128 * r.");const u=await r(e,t,1,128*f*s),c=new Uint32Array(u);for(let e=0;e<f;e++){const r=32*s,t=e*r,n=c.slice(t,t+r);a(n,o);for(let e=0;e<32*s;e++)c[t+e]=n[e]}return await r(e,c,1,n)}function f(e=16){if(!Number.isInteger(e)||e<0)throw new RangeError("length must be integer >= 0");return 0===e?new ArrayBuffer:crypto.getRandomValues(new Uint8Array(e)).buffer}function u(e,r){for(let t=0;t<e.length;t++)e[t]^=r[t]}export{i as salsa208Core,f as salt,s as scrypt,o as scryptBlockMix,a as scryptROMix};
