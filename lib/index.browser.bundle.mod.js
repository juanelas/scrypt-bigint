function t(t,e){for(let n=0;n<t.length;n++)t[n]^=e[n]}function e(t,e,n,r){return t=(new TextEncoder).encode(t),new Promise((o,i)=>{crypto.subtle.importKey("raw",t,"PBKDF2",!1,["deriveBits"]).then(t=>{const c={name:"PBKDF2",hash:"SHA-256",salt:e,iterations:n};crypto.subtle.deriveBits(c,t,8*r).then(t=>o(t),t=>i(t))},t=>i(t))})}function n(t){function e(t,e){return t<<e|t>>>32-e}const n=t.slice(0);for(let t=8;t>0;t-=2)n[4]^=e(n[0]+n[12],7),n[8]^=e(n[4]+n[0],9),n[12]^=e(n[8]+n[4],13),n[0]^=e(n[12]+n[8],18),n[9]^=e(n[5]+n[1],7),n[13]^=e(n[9]+n[5],9),n[1]^=e(n[13]+n[9],13),n[5]^=e(n[1]+n[13],18),n[14]^=e(n[10]+n[6],7),n[2]^=e(n[14]+n[10],9),n[6]^=e(n[2]+n[14],13),n[10]^=e(n[6]+n[2],18),n[3]^=e(n[15]+n[11],7),n[7]^=e(n[3]+n[15],9),n[11]^=e(n[7]+n[3],13),n[15]^=e(n[11]+n[7],18),n[1]^=e(n[0]+n[3],7),n[2]^=e(n[1]+n[0],9),n[3]^=e(n[2]+n[1],13),n[0]^=e(n[3]+n[2],18),n[6]^=e(n[5]+n[4],7),n[7]^=e(n[6]+n[5],9),n[4]^=e(n[7]+n[6],13),n[5]^=e(n[4]+n[7],18),n[11]^=e(n[10]+n[9],7),n[8]^=e(n[11]+n[10],9),n[9]^=e(n[8]+n[11],13),n[10]^=e(n[9]+n[8],18),n[12]^=e(n[15]+n[14],7),n[13]^=e(n[12]+n[15],9),n[14]^=e(n[13]+n[12],13),n[15]^=e(n[14]+n[13],18);for(let e=0;e<16;++e)t[e]=n[e]+t[e]}function r(e){const r=e.byteLength/128,o=8*(2*r-1),i=e.slice(o,o+8);let c=!1;for(let o=0;o<2*r;o++){const s=8*o;t(i,e.subarray(s,s+8)),n(new Uint32Array(i.buffer));let f=o>>1;c&&(f+=r);for(let t=0;t<8;t++)e[8*f+t]=i[t];c=!c}}function o(e,n){const o=new Array(n);for(let t=0;t<n;t++)o[t]=e.slice(0),r(e);function i(t){const r=64*(2*e.byteLength/128-1),o=new DataView(t.buffer,r,64),i=BigInt(n);let c=0n;for(let t=7;t>=0;t--)c=((c<<64n)+o.getBigUint64(t,!0))%i;return c<0&&(c+=i),c}for(let c=0;c<n;c++){const n=i(e);t(e,o[n]),r(e)}}async function i(t,n,r,i,c,s){const f=await e(t,n,1,128*c*i),l=new DataView(f);for(let t=0;t<c;t++){const e=64*t,n=new BigUint64Array(f.slice(e,e+64));o(n,r);for(let e=0;e<8;e++)l.setBigUint64(8*t+e,n[e])}return await e(t,f,1,s)}export{e as pbkdf2HmacSha256,n as salsa208Core,i as scrypt,r as scryptBlockMix,o as scryptROMix};
