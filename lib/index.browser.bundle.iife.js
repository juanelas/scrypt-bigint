var scryptBigint=function(e){"use strict";function r(e,r){for(let t=0;t<e.length;t++)e[t]^=r[t]}function t(e,r,t,n){return"string"==typeof e?e=(new TextEncoder).encode(e):ArrayBuffer.isView(e)||(e=new Uint8Array(e)),"string"==typeof r?r=(new TextEncoder).encode(r):ArrayBuffer.isView(r)||(r=new Uint8Array(r)),new Promise((i,o)=>{crypto.subtle.importKey("raw",e,"PBKDF2",!1,["deriveBits"]).then(e=>{const s={name:"PBKDF2",hash:"SHA-256",salt:r,iterations:t};crypto.subtle.deriveBits(s,e,8*n).then(e=>i(e),e=>o(e))},e=>o(e))})}function n(e){function r(e,r){return e<<r|e>>>32-r}const t=e.slice(0);for(let e=8;e>0;e-=2)t[4]^=r(t[0]+t[12],7),t[8]^=r(t[4]+t[0],9),t[12]^=r(t[8]+t[4],13),t[0]^=r(t[12]+t[8],18),t[9]^=r(t[5]+t[1],7),t[13]^=r(t[9]+t[5],9),t[1]^=r(t[13]+t[9],13),t[5]^=r(t[1]+t[13],18),t[14]^=r(t[10]+t[6],7),t[2]^=r(t[14]+t[10],9),t[6]^=r(t[2]+t[14],13),t[10]^=r(t[6]+t[2],18),t[3]^=r(t[15]+t[11],7),t[7]^=r(t[3]+t[15],9),t[11]^=r(t[7]+t[3],13),t[15]^=r(t[11]+t[7],18),t[1]^=r(t[0]+t[3],7),t[2]^=r(t[1]+t[0],9),t[3]^=r(t[2]+t[1],13),t[0]^=r(t[3]+t[2],18),t[6]^=r(t[5]+t[4],7),t[7]^=r(t[6]+t[5],9),t[4]^=r(t[7]+t[6],13),t[5]^=r(t[4]+t[7],18),t[11]^=r(t[10]+t[9],7),t[8]^=r(t[11]+t[10],9),t[9]^=r(t[8]+t[11],13),t[10]^=r(t[9]+t[8],18),t[12]^=r(t[15]+t[14],7),t[13]^=r(t[12]+t[15],9),t[14]^=r(t[13]+t[12],13),t[15]^=r(t[14]+t[13],18);for(let r=0;r<16;++r)e[r]=t[r]+e[r]}function i(e){const t=e.byteLength/128,i=8*(2*t-1),o=e.slice(i,i+8),s=new BigUint64Array(e.length/2);let a=!0;for(let i=0;i<2*t;i++){const t=8*i;r(o,e.subarray(t,t+8)),n(new Uint32Array(o.buffer));const f=i>>1;if(a)for(let r=0;r<8;r++)e[8*f+r]=o[r];else for(let e=0;e<8;e++)s[8*f+e]=o[e];a=!a}const f=8*t;for(let r=0;r<8*t;r++)e[f+r]=s[r]}function o(e,t){const n=e.byteLength/128,o=new Array(t);for(let r=0;r<t;r++)o[r]=e.slice(0),i(e);const s=BigInt(t);function a(e){const r=64*(2*n-1);return new DataView(e.buffer,r,64).getBigUint64(0,!0)%s}for(let n=0;n<t;n++){r(e,o[a(e)]),i(e)}}return e.pbkdf2HmacSha256=t,e.salsa208Core=n,e.scrypt=async function(e,r,n,i,s,a){if("string"==typeof e)e=(new TextEncoder).encode(e);else if(e instanceof ArrayBuffer)e=new Uint8Array(e);else if(!ArrayBuffer.isView(e))throw RangeError("P should be string, ArrayBuffer, TypedArray, DataView");if("string"==typeof r)r=(new TextEncoder).encode(r);else if(r instanceof ArrayBuffer)r=new Uint8Array(r);else if(!ArrayBuffer.isView(r))throw RangeError("S should be string, ArrayBuffer, TypedArray, DataView");if(!Number.isInteger(n)||n<=0||0!=(n&n-1))throw RangeError("N must be a power of 2");if(!Number.isInteger(i)||i<=0||!Number.isInteger(s)||s<=0||s*i>1073741823.75)throw RangeError("Parallelization parameter p and blosize parameter r must be positive integers satisfying p ≤ (2^32− 1) * hLen / MFLen where hLen is 32 and MFlen is 128 * r.");if(!Number.isInteger(a)||a<=0||a>137438953440)throw RangeError("dkLen is the intended output length in octets of the derived key; a positive integer less than or equal to (2^32 - 1) * hLen where hLen is 32");const f=await t(e,r,1,128*s*i),c=new BigUint64Array(f);for(let e=0;e<s;e++){const r=16*i,t=e*r,s=c.slice(t,t+r);o(s,n);for(let e=0;e<16*i;e++)c[t+e]=s[e]}return await t(e,c,1,a)},e.scryptBlockMix=i,e.scryptROMix=o,e}({});
